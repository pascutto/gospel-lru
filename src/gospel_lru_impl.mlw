module Table
  use mach.int.Int63
  use option.Option
  use ocaml.Pervasives
  use map.Map
  use fmap.Fmap

  type key

  type t 'v = abstract {
    mutable to_fmap: fmap key 'v;
  }
  meta coercion function to_fmap

  val create (_: int63) : t 'v
    ensures { result.to_fmap = empty }

  val mem (m: t 'v) (k: key) : bool
    ensures { result <-> mem k m }

  val replace (m: t 'v) (k: key) (v: 'v) : unit
    writes  { m }
    ensures { m = add k v (old m) }

  val find (m: t 'v) (k: key) : 'v
    ensures { mem k m }
    ensures { result = m[k] }
    raises  { Not_found ->  not (S.mem k m.domain) }

  val function find_opt (m: t 'v) (k: key) : option 'v
    ensures { result = if mem k m then Some m[k] else None }

  val remove (m: t 'v) (k: key) : unit
    writes  { m }
    ensures { m = remove k (old m) }

  val clear (m: t 'v) : unit
    writes  { m }
    ensures { m = empty }

  val length (m: t 'v) : int
    ensures { result = 0 <-> is_empty m }

end

module DLList
  use int.Int
  use mach.int.Int63
  use map.Map
  use seq.Seq
  use mach.array.Array63
  use option.Option

  type t 'a = {
    contents: array 'a;
    witness: 'a;
    prev: array int63;
    next: array int63;
    mutable first: int63;
    mutable last: int63;
    cap: int63;
    mutable size: int63;
    mutable ghost occupied : int -> bool;
    mutable ghost age : int -> int;
  }
  invariant { Array63.length contents
              = Array63.length prev
              = Array63.length next
              = cap }

  invariant { cap >= 2 }
  invariant { 0 <= size <= cap }

  invariant { size <> 0 -> cap - size <= first < cap /\ cap - size <= last < cap }

  invariant { forall i.          cap - size <= i < cap -> occupied i = true }
  invariant { forall i. 0 <= i < cap - size            -> occupied i = false }

  invariant { forall i. cap - size <= i < cap -> i <> last -> cap - size <= next[i] < cap }
  invariant { forall i. cap - size <= i < cap -> i <> first -> cap - size <= prev[i] < cap }

  invariant { forall i. 0 <= i < cap - size -> contents[i] = witness }

  invariant { size <> 0 -> occupied last = true }
  invariant { size <> 0 -> occupied first = true }

  invariant { forall i. cap - size <= i < cap -> i <> first -> next[prev[i]] = i }
  invariant { forall i. cap - size <= i < cap -> i <> last -> prev[next[i]] = i }

  invariant { cap - size <= first < cap -> age first = 0 }
  invariant { cap - size <= first < cap -> age last = size - 1 }
  invariant { forall i. cap - size <= i < cap -> 0 <= age i < size }
  invariant { forall i j. cap - size <= i < cap -> cap - size <= j < cap -> i <> j -> age i <> age j }
  invariant { forall i. cap - size <= i < cap -> i <> first -> age (prev[i]) = age i - 1 }
  invariant { forall i. cap - size <= i < cap -> i <> last -> age (next[i]) = age i + 1 }
  by {
    contents = Array63.make 2 (any 'a);
    witness = any 'a;
    prev = Array63.init 2 (fun _ -> Int63.zero);
    next = Array63.init 2 (fun _ -> Int63.one);
    first = 0;
    last = 1;
    cap = 2;
    size = 2;
    occupied = (fun _ -> true);
    age = (fun i -> i);
  }

  let create witness (c: int63) : t 'a
  requires { c >= 2 }
  ensures { result.size = 0 }
  =
  {
    contents = Array63.make c witness;
    witness = witness;
    prev = Array63.make c (-1);
    next = Array63.make c (-1);
    first = -1;
    last = -1;
    cap = c;
    size = 0;
    occupied = (fun _ -> false);
    age = (fun _ -> to_int c);
  }

  let clear (t: t 'a) : unit
  ensures { t.size = 0 }
  =
  t.size <- 0;
  let current_cap = t.cap in
  t.age <- (fun _ -> to_int current_cap);
  for i = 0 to t.cap - 1 do
    invariant { forall j. 0 <= j < i -> t.contents[j] = t.witness }
    t.contents[i] <- t.witness;
  done;
  t.occupied <- (fun _ -> false)

  let append (t: t 'a) (v: 'a) : (int63, option 'a)
    ensures { t.size >= (old t).size }
    returns { i, _ -> forall j. t.age j = if j = i then 0 else old (t.age j) + 1 }
  =
  let removed =
    if t.size = 0 then (
      let index = t.cap - 1 in
      t.contents[index] <- v;
      t.occupied <- Map.set t.occupied (to_int index) true;
      t.last <- index;
      t.first <- index;
      t.size <- 1;
      None
    )
    else if t.size < t.cap then (
      let index = t.cap - t.size - 1 in
      t.contents[index] <- v;
      t.occupied <- Map.set t.occupied (to_int index) true;
      t.next[index] <- t.first;
      t.prev[t.first] <- index;
      t.first <- index;
      t.size <- t.size + 1;
      None
    )
    else (* the structure is full *) (
      assert { t.size = t.cap };
      assert { t.next[t.first] = -1 <-> t.prev[t.last] = -1 <-> t.cap = 1 };
      assert { t.cap > 1 };
      assert { t.first <> t.last };
      assert {t.prev[t.last] <> -1};
      let removed = Some t.contents[t.last] in
      let old_last = t.last in
      (* FIXME *)
      t.last <- t.prev[old_last];
      t.contents[old_last] <- v;
      t.next[t.prev[old_last]] <- -1;
      t.prev[old_last] <- -1;
      t.next[old_last] <- t.first;
      t.prev[t.first] <- old_last;
      t.first <- old_last;
      removed
    )
  in
  let old_age = t.age in
  let f = to_int t.first in
  t.age <- (fun i -> if i = f then 0 else old_age i + 1);
  t.first, removed

  let promote (t: t 'a) (i: int63) : int63
    requires { t.cap - t.size <= i < t.cap }
    ensures { t.size = (old t).size }
    ensures { t.cap - t.size <= result < t.cap }
    ensures { forall k. t.cap - t.size <= k < t.cap ->
    age t k =
      if k = i then 0
      else if age (old t) k < age (old t) i then age (old t) k + 1
      else age (old t) k }
  =
  if i = t.first then return i;
  if i <> t.last (* && i <> t.first *) then (
    let prev_i = t.prev[i] in
    let next_i = t.next[i] in
    t.next[prev_i] <- next_i;
    t.prev[next_i] <- prev_i
  ) else (
    t.last <- t.prev[i];
  );
  t.prev[t.first] <- i;
  t.next[i] <- t.first;
  assert { t.prev[t.next[i]] = i };
  t.first <- i;
  let old_age = t.age in
  assert { forall i. t.cap - t.size <= i < t.cap -> 0 <= old_age i };
  let new_age = (fun j -> if j = to_int i then 0
            else if old_age j < old_age (to_int i) then old_age j + 1
            else old_age j) in
  t.age <- new_age;
  assert { forall i. t.cap - t.size <= i < t.cap -> 0 <= t.age i };
  t.first

  let get (t: t 'a) (i: int63) : 'a
    requires { t.cap - t.size <= i < t.cap }
  = t.contents[i]

  val function mem (t: t 'a) (v: 'a) : bool
  ensures { result <-> exists i. t.contents[i] = v}
end

module Impl

  use DLList as DLList
  use int.Int
  use mach.int.Int63
  use option.Option
  use ocaml.Pervasives
  use fmap.Fmap

  scope Make

    scope K
      type key
      val equal (k: key) (k': key) : bool
      ensures { result <-> k = k' }
      val witness : key
    end

    clone Table as H with type key = K.key

    type t 'a = {
      tbl: H.t (int63, 'a);
      lst: DLList.t K.key;
      cap : int63;
      mutable ghost assoc: K.key -> option 'a;
      mutable ghost age: K.key -> int
    }
    invariant { cap > 0 }
(*
    invariant { forall k. if mem k tbl then let _,v = tbl k in assoc k = Some v
                                       else assoc k = None }
*)
    invariant { forall k. match assoc k with
      | None -> not mem k tbl
      | Some v -> mem k tbl && let _, v' = tbl k in v = v'
    end }
    invariant { DLList.size lst = size tbl }
    invariant { forall k. age k >= cap <-> assoc k = None }
    by {
      tbl = H.create 0;
      lst = DLList.create K.witness 2;
      cap = 2;
      assoc = (fun _ -> None);
      age = (fun _ -> 2);
    }

    let unsafe_v (c: int63)
      requires { c >= 2 }
      ensures { forall k. result.assoc k = None }
      ensures { result.cap = c }
    =
    {
      tbl = H.create c;
      lst = DLList.create K.witness c;
      cap = c;
      assoc = (fun _ -> None);
      age = (fun _ -> to_int c)
    }

    let v (c: int63) : t 'a
      raises { Invalid_argument _ -> c < 2 }
      ensures { forall k. result.assoc k = None }
      ensures { result.cap = c }
    =
    if c < 2 then raise Invalid_argument "capacity must be strictly positive";
    unsafe_v c

    let clear (t: t 'a)
      ensures { forall k. t.assoc k = None }
    =
    t.assoc <- (fun _ -> None);
    let c = t.cap in
    t.age <- (fun _ -> to_int c);
    H.clear t.tbl;
    DLList.clear t.lst

    let is_empty (t: t 'a) : bool
      ensures { result <-> forall k. t.assoc k = None }
    =
      H.length t.tbl = 0

    let capacity t
      ensures { result = t.cap }
    = t.cap

    let mem (k: K.key) (t: t 'a) : bool
      ensures { result <-> t.assoc k <> None }
    = (* enforce case analysis *)
      ghost (match t.assoc k with None -> () | Some _ -> () end);
      H.mem t.tbl k


    let find (k: K.key) (t: t 'a) : 'a
      ensures { Some result = t.assoc k }
      raises { Not_found -> t.assoc k = None }
    =
    let _index, value = H.find t.tbl  k in
    value

    let find_opt (k: K.key) (t: t 'a) : option 'a
      ensures { result = t.assoc k }
    =
    try Some (find k t) with Not_found -> None end

    let add (k: K.key) (v: 'a) (t: t 'a) : unit
    ensures { t.assoc k = Some v }
    ensures { forall k', v'.
      k <> k' -> t.assoc k' = Some v' -> (old t).assoc k' = Some v' }
    ensures { forall k'. age t k' =
      if k = k' then 0
      else if age (old t) k' < age (old t) k then age (old t) k' + 1
      else age (old t) k' }
    =
    let old_assoc = t.assoc in
    match H.find_opt t.tbl k with
    | Some (index, _value) ->
      let new_index = DLList.promote t.lst index in
      H.replace t.tbl k (new_index, v);
      t.assoc <- (fun x -> if K.equal k x then Some v else old_assoc x);
    | None -> (
      let index, removed = DLList.append t.lst k in
      match removed with
      | None -> t.assoc <- (fun x -> if K.equal k x then Some v else old_assoc x);
      | Some key -> (
        H.remove t.tbl key;
        t.assoc <- (fun x ->
          if K.equal k x then Some v
          else if K.equal key x then None
          else old_assoc x))
      end;
      H.replace t.tbl k (index, v));
    end;
    let old_age = t.age in
    t.age <- (fun k' ->
      if K.equal k k' then 0
      else if old_age k' < old_age k then old_age k' + 1
      else old_age k')
  end
end

(*
module Correct

  use Impl as L

  clone gospel_lru.Sig with
     type Make.t = L.Make.t,
     val Make.v = L.Make.v,
     val Make.clear = L.Make.clear,
     val Make.is_empty = L.Make.is_empty,
     val Make.capacity = L.Make.capacity,
     val Make.mem = L.Make.mem,
     val Make.find = L.Make.find,
     val Make.find_opt = L.Make.find_opt,
     val Make.add = L.Make.add
end
*)