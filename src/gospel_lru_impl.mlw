module Table
  use mach.int.Int63
  use option.Option
  use ocaml.Pervasives
  use map.Map
  use fmap.Fmap
  
  type key

  type t 'v = abstract {
    mutable to_fmap: fmap key 'v;
  }
  meta coercion function to_fmap

  val create (_: int63) : t 'v
    ensures { result.to_fmap = empty }

  val mem (m: t 'v) (k: key) : bool
    ensures { result <-> mem k m }

  val replace (m: t 'v) (k: key) (v: 'v) : unit
    writes  { m }
    ensures { m = add k v (old m) }

  val find (m: t 'v) (k: key) : 'v
    ensures { mem k m }
    ensures { result = m[k] }
    raises  { Not_found ->  not (S.mem k m.domain) }

  val function find_opt (m: t 'v) (k: key) : option 'v
    ensures { result = if mem k m then Some m[k] else None }

  val remove (m: t 'v) (k: key) : unit
    writes  { m }
    ensures { m = remove k (old m) }

  val clear (m: t 'v) : unit
    writes  { m }
    ensures { m = empty }

  val function length (m: t 'v) : int
    ensures { result = size m }
    
  lemma length_empty:
    forall m: t 'v. size m = 0 <-> m = empty
    
  lemma length_nonempty:
    forall m: t 'v. size m <> 0 <-> exists k. mem k m
end
  
module DLList
  use int.Int
  use mach.int.Int63
  use seq.Seq
  use mach.array.Array63
  use option.Option

  type t 'a = {
    contents: array 'a;
    witness: 'a;
    prev: array int63;
    next: array int63;
    mutable first: int63;
    mutable last: int63;
    cap: int63;
    mutable size: int63;
    ghost occupied : array bool;
    ghost age : array int;
  }
  invariant { Array63.length contents 
              = Array63.length prev 
              = Array63.length next 
              = Array63.length occupied 
              = Array63.length age
              = cap }
  
  invariant { cap >= 2 }
  invariant { 0 <= size <= cap }
  
  invariant { size <> 0 -> cap - size <= first < cap /\ cap - size <= last < cap }
  
  invariant { forall i.          cap - size <= i < cap -> occupied[i] = true }
  invariant { forall i. 0 <= i < cap - size            -> occupied[i] = false }
  
  invariant { forall i. cap - size <= i < cap -> i <> last -> next[i] <> i }
  invariant { forall i. cap - size <= i < cap -> i <> first -> prev[i] <> i }
  
  invariant { forall i. cap - size <= i < cap -> i <> last -> cap - size <= next[i] < cap }
  invariant { forall i. cap - size <= i < cap -> i <> first -> cap - size <= prev[i] < cap }
  
  invariant { forall i. 0 <= i < cap - size -> contents[i] = witness }

  invariant { size <> 0 -> occupied[last] = true }
  invariant { size <> 0 -> occupied[first] = true }
  
  invariant { forall i. cap - size <= i < cap -> next[i] <> i }
  invariant { forall i. cap - size <= i < cap -> prev[i] <> i }
  
  invariant { forall i. cap - size <= i < cap -> i <> first -> next[prev[i]] = i }
  invariant { forall i. cap - size <= i < cap -> i <> last -> prev[next[i]] = i }
  
  invariant { forall i. cap - size <= i < cap -> age[i] < cap }
  invariant { cap - size <= first < cap -> age[first] = 0 }
  invariant { forall i. cap - size <= i < cap -> i <> first -> age[prev[i]] = age[i] - 1 }
  invariant { forall i. cap - size <= i < cap -> i <> last -> age[next[i]] = age[i] + 1 }
  by {
    contents = Array63.make 2 (any 'a);
    witness = any 'a;
    prev = Array63.init 2 (fun _ -> Int63.zero);
    next = Array63.init 2 (fun _ -> Int63.one);
    first = 0;
    last = 1;
    cap = 2;
    size = 2;
    occupied = Array63.make 2 true;
    age = Array63.init 2 (fun i -> to_int i);
  }
  
  let create witness (c: int63) : t 'a
  requires { c >= 2 }
  ensures { result.size = 0 }
  =
  {
    contents = Array63.make c witness;
    witness = witness;
    prev = Array63.make c (-1);
    next = Array63.make c (-1);
    first = -1;
    last = -1;
    cap = c;
    size = 0;
    occupied = Array63.make c false;
    age = Array63.make c (to_int c);
  }
  
  let clear t
  ensures { t.size = 0 }
  =
  t.size <- 0;
  for i = 0 to t.cap - 1 do
    invariant { forall j. 0 <= j < i -> t.occupied[j] = false }
    invariant { forall j. 0 <= j < i -> t.contents[j] = t.witness }
    t.contents[i] <- t.witness;
    t.occupied[i] <- false;
    t.age[i] <- to_int t.cap;
  done
  
  let append t v
  ensures { t.size >= (old t).size }
  =
  let removed =
    if t.size = 0 then (
      let index = t.cap - 1 in
      t.contents[index] <- v;
      t.occupied[index] <- true;
      t.last <- index;
      t.first <- index;
      t.size <- 1;
      None
    )
    else if t.size < t.cap then (
      let index = t.cap - t.size - 1 in
      t.contents[index] <- v;
      t.occupied[index] <- true;
      t.next[index] <- t.first;
      t.prev[t.first] <- index;
      t.first <- index;
      t.size <- t.size + 1;
      None
    )
    else (* the structure is full *) (
      assert { t.size = t.cap };
      assert { t.next[t.first] = -1 <-> t.prev[t.last] = -1 <-> t.cap = 1 };
      assert { t.cap > 1 };
      assert { t.first <> t.last };
      assert {t.prev[t.last] <> -1};
      let removed = Some t.contents[t.last] in
      let old_last = t.last in
      (* FIXME *)
      t.last <- t.prev[old_last];
      t.contents[old_last] <- v;
      t.next[t.prev[old_last]] <- -1;
      t.prev[old_last] <- -1;
      t.next[old_last] <- t.first;
      t.prev[t.first] <- old_last;
      t.first <- old_last;
      removed
    )
  in
  t.first, removed
  
  let promote (t: t 'a) (i: int63) : int63
    requires { t.cap - t.size <= i < t.cap }
    ensures { t.size = (old t).size }
    ensures { t.cap - t.size <= result < t.cap } 
  =
  if i = t.first then return i;
  if i <> t.last (* && i <> t.first *) then (
    let prev_i = t.prev[i] in
    let next_i = t.next[i] in
    t.next[prev_i] <- next_i;
    t.prev[next_i] <- prev_i;
    assert { t.next[prev_i] = next_i });
  t.prev[t.first] <- i;
  t.next[i] <- t.first;
  t.first <- i;
  for j = t.cap - t.size to t.cap - 1 do
    t.age[j] <- if j = t.first then 0 else t.age[j] + 1 
  done;
  t.first

  let get t i
    requires { t.cap - t.size <= i < t.cap }
  = t.contents[i]
  
  let function length t
  = t.size
  
  val function mem (t: t 'a) (v: 'a) : bool
  ensures { result <-> exists i. t.contents[i] = v}
end

module Impl

  use DLList as DLList
  use int.Int
  use mach.int.Int63
  use option.Option
  use ocaml.Pervasives

  scope Make
 
    scope K
      type key
      val equal (k: key) (k': key) : bool
      ensures { result <-> k = k' }
      val witness () : key
    end
    
    clone Table as H with type key = K.key
  
    type t 'a = {
      tbl: H.t (int63, 'a);
      lst: DLList.t K.key;
      cap : int63;
      mutable ghost assoc: K.key -> option 'a;
      mutable ghost age: K.key -> int
    }
    invariant { cap > 0 }
    invariant { forall k. assoc k = match H.find_opt tbl k with 
      | None -> None 
      | Some (_, v) -> Some v 
    end }
    invariant { DLList.length lst = H.length tbl }
    invariant { forall k. age k >= cap <-> assoc k = None }
    by {
      tbl = H.create 0;
      lst = DLList.create (K.witness ()) 1;
      cap = 1;
      assoc = (fun _ -> None);
      age = (fun _ -> 1);
    }

    let unsafe_v (c: int63)
      requires { c > 0 }
      ensures { forall k. result.assoc k = None }
      ensures { result.cap = c }
    =
    let witness = K.witness () in
    {
      tbl = H.create c;
      lst = DLList.create witness c;
      cap = c;
      assoc = (fun _ -> None); 
      age = (fun _ -> to_int c)
    }
      
    let v (c: int63) : t 'a
      raises { Invalid_argument _ -> c <= 0 }
      ensures { forall k. result.assoc k = None }
      ensures { result.cap = c }
    =
    if c <= 0 then raise Invalid_argument "capacity must be strictly positive";
    unsafe_v c

    let clear (t: t 'a) 
      ensures { forall k. t.assoc k = None }
    =
    t.assoc <- (fun _ -> None);
    let c = t.cap in
    t.age <- (fun _ -> to_int c);
    H.clear t.tbl;
    DLList.clear t.lst

    let is_empty (t: t 'a)
      ensures { result <-> forall k. t.assoc k = None }
    = 
    let res = H.length t.tbl = 0 in
    assert { res -> forall k. H.find_opt t.tbl k = None };
    res

    let capacity t
      ensures { result = t.cap }  
    = t.cap
    
    let mem (k: K.key) (t: t 'a) : bool 
      ensures { result <-> t.assoc k <> None }
    = match H.find_opt t.tbl k with None -> false | Some _ -> true end

    let find (k: K.key) (t: t 'a) : 'a
      ensures { Some result = t.assoc k }
      raises { Not_found -> t.assoc k = None }
    = 
    let _index, value = H.find t.tbl  k in
    value
    
    let find_opt (k: K.key) (t: t 'a) : option 'a 
      ensures { result = t.assoc k }
    =
    try Some (find k t) with Not_found -> None end
      
    let add (k: K.key) (v: 'a) (t: t 'a) : unit 
    ensures { t.assoc k = Some v }
    ensures { forall k', v'.
      k <> k' -> t.assoc k' = Some v' -> (old t).assoc k' = Some v' }
    ensures { forall k'. age t k' =
      if k = k' then 0
      else if age (old t) k' < age (old t) k then age (old t) k' + 1
      else age (old t) k' }
    =
    let old_assoc = t.assoc in
    match H.find_opt t.tbl k with
    | Some (index, _value) ->
      let new_index = DLList.promote t.lst index in
      H.replace t.tbl k (new_index, v);
      t.assoc <- (fun x -> if K.equal k x then Some v else old_assoc x);
    | None -> (
      let index, removed = DLList.append t.lst k in
      match removed with
      | None -> t.assoc <- (fun x -> if K.equal k x then Some v else old_assoc x);
      | Some key -> (
        H.remove t.tbl key;
        t.assoc <- (fun x ->
          if K.equal k x then Some v
          else if K.equal key x then None  
          else old_assoc x))
      end;
      H.replace t.tbl k (index, v));
    end;
    let old_age = t.age in
    t.age <- (fun k' -> 
      if K.equal k k' then 0
      else if old_age k' < old_age k then old_age k' + 1
      else old_age k')
  end
end

(*
module Correct

  use Impl as L

  clone gospel_lru.Sig with
     type Make.t = L.Make.t,
     val Make.v = L.Make.v,
     val Make.clear = L.Make.clear,
     val Make.is_empty = L.Make.is_empty,
     val Make.capacity = L.Make.capacity,
     val Make.mem = L.Make.mem,
     val Make.find = L.Make.find,
     val Make.find_opt = L.Make.find_opt,
     val Make.add = L.Make.add
end
*)